---
title: "EDCHM"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{EDCHM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(EDCHM)
```


# Three Ways to Obtain One Model

`EDCHM` provides three methods for obtaining a hydrological model that simulates the hydrological process.

## Use the Pre-Defined Model

`EDCHM` offers three pre-defined models:
(Note: models with the `_full` suffix will return all variables in a `list`. 
Otherwise, the standard model returns only the stream flow to speed up the calibration process.)

- `EDCHM_GR4J()` and `EDCHM_GR4J_full()`: original GR4J model, same as `airGR::RunModel_GR4J()`.
- `EDCHM_mini()` and `EDCHM_mini_full()`: a minimal model structure with random process method.
- `EDCHM_snow()` and `EDCHM_snow_full()`: a snow-structure model with random process method.

The function arguments will show all the **boundary (input) variable** and **parameters**

## Create a Model with a Pre-Defined Model Structure

The `build_modell()` function offers a standard structure that contains 15 processes and 34 sub-structures, 
which can generate more than ten millions models.

To build a model, you only need to:

1. Provide the method name for every process:

```{r buildMdell1}
## select the process method
my_process_method <- c( 
atmosSnow = "atmosSnow_ThresholdT",
evatransPotential = "NULL",
evatransLand = "NULL",
evatransSoil = "evatransActual_SupplyRatio",
intercep = "NULL",
snowMelt = "snowMelt_Kustas",
infilt = "infilt_AcceptRatio",
percola = "percola_SupplyRatio",
inteflow = "NULL",
capirise = "NULL",
baseflow = "baseflow_SupplyRatio",
lateral = "lateral_GR4Jfix",
confluenLand = "confluenIUH_Kelly",
confluenSoil = "NULL",
confluenGround = "confluenIUH_Nash"
)
```

2. Create the model with `build_modell()`, this function will return the **rang of all parameters** in R-Space and a **.cpp-file** in a folder, which represents the model.

**NOTE: Make sure that there is no model with the same name in the file path.**

```{r buildMdell2}
## build
my_ParamRange <- build_modell(my_process_method, "E:\\Kan_Lei\\try", "TestModel")

## check
my_ParamRange
```

The .cpp-file looks like the [source code of EDCHM_mini](https://github.com/LuckyKanLei/EDCHM/blob/main/src/EDCHM_mini.cpp), which will be shown in the next section on how to use it.

## Manually build a model with EDCHM modules

Although `build_modell()` offers the possibility of generating over a million models, there may still be a requirement to create a model with a different structure. For example, it may involve adding or deleting some processes, or adding more layers.


As shown in the model [source code of EDCHM_mini](https://github.com/LuckyKanLei/EDCHM/blob/main/src/EDCHM_mini.cpp), it is straightforward to assemble a model with EDCHM modules. The steps are as follows:

1. Select the deciding processes and their methods.
2. Fill the arguments of the module (function) with specific variables and parameters. The original argument names are well-defined, so they can be used as variable names.
3. Complete the boundary conditions (BC) variables (input, meteorological data) in matrix-form. The BC variables are always given as time series, so they must be in matrix form, for example, `atmos_precipitation_mm` and `atmos_potentialEvatrans_mm`.
4. Complete the outflow variables in matrix-form. The outflow variables refer to the variables that will flow to the catchment outlet through "routing", for example, `land_runoff_mm` and `ground_baseflow_mm`.
5. Set the processing after the module, the relationship between the calculated process-variable and the standard variables.
6. Define all the parameters and input (BC) variables as arguments and declare all the other variables.

With these six steps, we can build a new model, but it is important to ensure that the logic of relationships between variables is correct.

# Run the model

## Run the pre-defined model from EDCHM

The pre-defined model can be used like normal functions. You just need to provide the input data and the parameters in the correct format as specified in the function arguments. For example:

## Run the model with cpp source code

If the model is still in CPP source code, you first need to compile it into a function using the `Rcpp::sourceCpp()` function. 
For example:

```{r eval = FALSE}

Rcpp::sourceCpp("path/to/your/model.cpp")

```

Once the model is compiled, you can use it as a normal function by providing the input data and parameters in the correct format.


